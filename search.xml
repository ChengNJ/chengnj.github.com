<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dial tcp lookup registry.cn-hangzhou.aliyuncs.com on 8.8.8.8:53 read udp 192.168.0.188:54861-&gt;8.8.8.8:53 i/o timeout</title>
    <url>/docker/2020/dockerpull/</url>
    <content><![CDATA[<p>在使用docker-compose pull进行拉取镜像的时候，出现timeout异常，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pulling police (registry.cn-hangzhou.aliyuncs.com&#x2F;aitensor-hub&#x2F;center-apps-police:3.2.1)...</span><br><span class="line">ERROR: Get https:&#x2F;&#x2F;registry.cn-hangzhou.aliyuncs.com&#x2F;v2&#x2F;aitensor-hub&#x2F;center-apps-police&#x2F;manifests&#x2F;3.2.1: dial tcp: lookup registry.cn-hangzhou.aliyuncs.com on 8.8.8.8:53: read udp 192.168.0.188:54861-&gt;8.8.8.8:53: i&#x2F;o timeout</span><br></pre></td></tr></table></figure>
<p>可能有的人的报错不是8.8.8.8而是114.114.114.114，这是dns服务器地址。<br>通过 <strong><em>192.168.0.188:54861-&gt;8.8.8.8:53</em></strong> 可以看出本次的超时原因可能是随机的本机（192.168.0.188）的端口无法正常访问。所以我们就绕过向dns服务器请求，<br>也就是直接把 registry.cn-hangzhou.aliyuncs.com 的ip映射直接写到hosts里面。</p>
<blockquote>
<ol>
<li>手动ping registry.cn-hangzhou.aliyuncs.com 获取得到ip</li>
<li>将 ip registry.cn-hangzhou.aliyuncs.com 写入到/etc/hosts中保存退出</li>
<li>重新pull镜像，如果出现同样的报错，重复1 2步骤将对应的ip 网址映射写到hosts即可</li>
</ol>
</blockquote>
<p>我大概添加了三条映射就可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">112.124.225.62    dockerauth.cn-hangzhou.aliyuncs.com</span><br><span class="line">120.55.105.209    registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">112.13.97.151     aliregistry.oss-cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>
<p>为了避免ip变动导致的错误，建议还是自己手动ping获取ip。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker问题</tag>
      </tags>
  </entry>
  <entry>
    <title>docker系列四使用Dockerfile创建镜像</title>
    <url>/docker/2020/docker4/</url>
    <content><![CDATA[<p><a href="/docker/2020/docker1/">docker系列一docker安装</a><br><a href="/docker/2020/docker2/">docker系列二docker配置优化</a><br><a href="docker/2020/docker3/">docker系列三docker基本操作</a></p>
<p>前面都是通过镜像仓库进行拉取别人构建好的镜像进行操作，所以这次我们进行编写dockerfile进行自定义构建镜像。</p>
<h1 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h1><p>docker中最常见的创建镜像方式就是使用Dockerfile。Dockerfile是docker镜像的描述文件，包含着一条条的指令，每一条指令构建一层，所以每一条指令的内容就是描述该层是如何被构建的。</p>
<h2 id="dockerfile示例"><a href="#dockerfile示例" class="headerlink" title="dockerfile示例"></a>dockerfile示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#基于centos镜像</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">#维护人信息</span><br><span class="line">MAINTAINER  the centos project &lt;*@qq.com&gt;</span><br><span class="line"></span><br><span class="line">#安装httpd软件包</span><br><span class="line">RUN yum -y update</span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"></span><br><span class="line">#复制网站首页文件到镜像web站点下</span><br><span class="line">COPY index.html &#x2F;var&#x2F;www&#x2F;html&#x2F;index.htm</span><br><span class="line"></span><br><span class="line">#复制脚本到镜像中并修改权限</span><br><span class="line">ADD run.sh &#x2F;run.sh</span><br><span class="line">RUN chmod 775 &#x2F;run.sh</span><br><span class="line"></span><br><span class="line">#开启80端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">#当容器启动时执行的命令</span><br><span class="line">CMD [&quot;&#x2F;run.sh&quot;]</span><br></pre></td></tr></table></figure>
<p>从上面的文档可以看出dockerfile结构大概可以分为4部分：</p>
<ol>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行的指令</li>
</ol>
<p>Dockerfile每行支持一条指令，每条指令可带多个参数，支持使用以#号开头的注释。下面会对上面使用到的一些常用指令做一些介绍。</p>
<h1 id="dockerfile中的基本命令"><a href="#dockerfile中的基本命令" class="headerlink" title="dockerfile中的基本命令"></a>dockerfile中的基本命令</h1><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>指定新构建的镜像是基于哪个基础镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:6</span><br></pre></td></tr></table></figure>
<h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p>指明镜像维护者以及联系方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAINTAINER XXX &lt;XXX@hotmail.com&gt;</span><br></pre></td></tr></table></figure>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>为RUN CMD ENTRYPOINT执行shell命令指定运行用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;user&gt;[:&lt;usergroup&gt;]</span><br><span class="line">USER &lt;UID&gt;[:&lt;UID&gt;]</span><br><span class="line">USER XXX</span><br></pre></td></tr></table></figure>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>构建镜像时运行的shell命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN [&quot;yum&quot;,&quot;-y&quot;,&quot;install&quot;,&quot;httpd&quot;]</span><br><span class="line">RUN yum -y install httpd</span><br></pre></td></tr></table></figure>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>拷贝文件或者目录到镜像中，如果是url或者压缩包，则会自动下载或者自动解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br><span class="line">ADD html.tar.gz &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">ADD https:&#x2F;&#x2F;xxx.com&#x2F;html.tar.gz &#x2F;var&#x2F;www&#x2F;html</span><br></pre></td></tr></table></figure>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>拷贝文件或者目录到镜像中，用法跟ADD一样，只不过不支持自动下载或者解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY .&#x2F;start.sh &#x2F;start.sh</span><br></pre></td></tr></table></figure>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>为RUN、CMD、ENTRYPOINT以及COPY和AND设置工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;data</span><br></pre></td></tr></table></figure>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p>指定容器挂载点到宿主机自动生成的目录或者其他容器,一般不会再dockerfile中使用，而是在docker run的时候用-v 数据卷使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;var&#x2F;lib&#x2F;mysql&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>声明容器运行的服务端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>启动容器时执行的shell命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD [&quot;-C&quot;, &quot;&#x2F;start.sh&quot;] </span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;, &quot;-D&quot;] </span><br><span class="line">CMD &#x2F;usr&#x2F;sbin&#x2F;sshd -D</span><br></pre></td></tr></table></figure>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>启动容器时执行的Shell命令，同CMD类似，只是由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定的程序，如果存在多个ENTRYPOINT指令，仅有最后一个有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-C&quot;, &quot;&#x2F;start.sh&quot;]</span><br><span class="line">ENTRYPOINT &#x2F;bin&#x2F;bash -C &#39;&#x2F;start.sh&#39;</span><br></pre></td></tr></table></figure>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>设置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV MYSQL_ROOT_PASSWORD 123456</span><br></pre></td></tr></table></figure>
<h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p>告诉docker如何检测容器以检查它是否正常工作，也就是健康检查<br> –interval=DURATION (default: 30s)：每隔多长时间探测一次，默认30秒<br> – timeout= DURATION (default: 30s)：服务响应超时时长，默认30秒<br> –start-period= DURATION (default: 0s)：服务启动多久后开始探测，默认0秒<br> –retries=N (default: 3)：认为检测失败几次为宕机，默认3次<br>一些返回值的说明：</p>
<p>  0：容器成功是健康的，随时可以使用<br>  1：不健康的容器无法正常工作<br>  2：保留不使用此退出代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK --interval&#x3D;5m --timeout&#x3D;3s --retries&#x3D;3 CMD curl -f http:&#x2F;localhost&#x2F; ||exit 1</span><br></pre></td></tr></table></figure>
<h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p>构建镜像时，指定一些参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:6</span><br><span class="line">ARG user</span><br><span class="line">USER $user</span><br></pre></td></tr></table></figure>
<p>然后我们在构建镜像的时候可以自定义参数user</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build --build-arg user&#x3D;root Dockerfile .</span><br></pre></td></tr></table></figure>
<h1 id="使用docker-build-进行构建镜像"><a href="#使用docker-build-进行构建镜像" class="headerlink" title="使用docker build 进行构建镜像"></a>使用docker build 进行构建镜像</h1><p>docker build [options]  path|url|- </p>
<blockquote>
<p>options:<br>–build-arg=[] :设置镜像创建时的变量；<br>–cpu-shares :设置 cpu 使用权重；<br>–cpu-period :限制 CPU CFS周期；<br>–cpu-quota :限制 CPU CFS配额；<br>–cpuset-cpus :指定使用的CPU id；<br>–cpuset-mems :指定使用的内存 id；<br>–disable-content-trust :忽略校验，默认开启；<br>-f :指定要使用的Dockerfile路径；<br>–force-rm :设置镜像过程中删除中间容器；<br>–isolation :使用容器隔离技术；<br>–label=[] :设置镜像使用的元数据；<br>-m :设置内存最大值；<br>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；<br>–no-cache :创建镜像的过程不使用缓存；<br>–pull :尝试去更新镜像的新版本；<br>–quiet, -q :安静模式，成功后只输出镜像 ID；<br>–rm :设置镜像成功后删除中间容器；<br>–shm-size :设置/dev/shm的大小，默认值是64M；<br>–ulimit :Ulimit配置。<br>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>–network: 默认 default。在构建期间设置RUN指令的网络模式</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t runoob&#x2F;ubuntu:v1 .</span><br></pre></td></tr></table></figure>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build github.com&#x2F;creack&#x2F;docker-firefox</span><br></pre></td></tr></table></figure>
<p>也可以通过 -f Dockerfile 文件的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</span><br></pre></td></tr></table></figure>
<h1 id="将镜像传输到仓库"><a href="#将镜像传输到仓库" class="headerlink" title="将镜像传输到仓库"></a>将镜像传输到仓库</h1><p>将本地的镜像推送到仓库中<br>docker push [registry-url/]namespace/img[:tag]</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker系列三docker命令</title>
    <url>/docker/2020/docker3/</url>
    <content><![CDATA[<p><a href="/2020/docker1/">docker系列一docker安装</a><br><a href="/2020/docker2/">docker系列二docker配置优化</a></p>
<p>经过前两篇的前期准备，这篇开始就可以真正地进入docker的实地操作啦！那么先来了解下docker的命令操作。以下所有涉及到容器的，既可以使用容器名称，也可以使用容器id(只需要输入id前3位即可，不行就四位。。。)</p>
<h1 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h1><h2 id="login-登录镜像仓库"><a href="#login-登录镜像仓库" class="headerlink" title="login 登录镜像仓库"></a>login 登录镜像仓库</h2><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>
<p>docker login [OPTIONS] [SERVER]<br>docker logout [OPTIONS] [SERVER]</p>
<blockquote>
<p>OPTIONS说明：<br>-u :登陆的用户名<br>-p :登陆的密码</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>登陆到Docker Hub</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码</span><br></pre></td></tr></table></figure>
<p>登出Docker Hub</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>
<p>登录到指定镜像仓库 例如阿里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker login --username&#x3D;你的账号 \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>
<h2 id="pull-拉取镜像"><a href="#pull-拉取镜像" class="headerlink" title="pull 拉取镜像"></a>pull 拉取镜像</h2><p>从镜像仓库中拉取或者更新指定镜像，可拉取一个或者多个<br>docker pull [options] [registry-url/]namespace/image[:tag]</p>
<blockquote>
<p>options<br>-a :拉取所有tagged镜像<br>–disable-content-trust :忽略镜像的校验,默认开启<br>registry-url 镜像仓库的地址，可不写，默认是从docker hub拉取，如果是其他镜像仓库，需要指定。<br>namespace 命名空间，镜像的所属命名空间<br>image 镜像名称<br>tag 镜像版本，如果没有的话 默认最新：latest</p>
</blockquote>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>拉取官方镜像hello-world</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>
<h2 id="push-推送镜像到仓库"><a href="#push-推送镜像到仓库" class="headerlink" title="push 推送镜像到仓库"></a>push 推送镜像到仓库</h2><p>将本地的镜像推送到仓库中<br>docker push [registry-url/]namespace/img[:tag]</p>
<h2 id="serch-查找镜像"><a href="#serch-查找镜像" class="headerlink" title="serch 查找镜像"></a>serch 查找镜像</h2><p>docker search : 从Docker Hub查找镜像<br>docker search [options] image</p>
<blockquote>
<p>options说明：<br>–automated :只列出 automated build类型的镜像；<br>–no-trunc :显示完整的镜像描述；<br>-s :列出收藏数不小于指定值的镜像。</p>
</blockquote>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search -s 10 java</span><br></pre></td></tr></table></figure>
<h1 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h1><h2 id="run-启动容器"><a href="#run-启动容器" class="headerlink" title="run 启动容器"></a>run 启动容器</h2><p>通过docker run可创建一个新容器并运行某个命令<br>docker run [options]] image [command] [arg…]</p>
<blockquote>
<p>options<br>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-P: 随机端口映射，容器内部端口随机映射到主机的高端口<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>–name=”容器名”: 为容器指定一个名称；<br>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；<br>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；<br>-h “mars”: 指定容器的hostname；<br>-e username=”ritchie”: 设置环境变量；<br>–env-file=[]: 从指定文件读入环境变量；<br>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；<br>-m :设置容器使用内存最大值；<br>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>–link=[]: 添加链接到另一个容器；<br>–expose=[]: 开放一个端口或一组端口；<br>–volume , -v: 绑定一个卷<br>command arg 容器启动运行的命令</p>
</blockquote>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v &#x2F;data:&#x2F;data -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 127.0.0.1:80:8080&#x2F;tcp ubuntu bash</span><br></pre></td></tr></table></figure>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it nginx:latest &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h2 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start stop restart"></a>start stop restart</h2><p>docker start: 启动一个或者多个已经被停止的容器<br>docker stop: 停止一个运行中的容器<br>docker restart: 重启容器</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>启动已被停止的容器nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start nginx</span><br></pre></td></tr></table></figure>
<p>停止运行中的容器nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop nginx</span><br></pre></td></tr></table></figure>
<p>重启容器nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart nginx</span><br></pre></td></tr></table></figure>
<h2 id="rm-移除一个或多个容器"><a href="#rm-移除一个或多个容器" class="headerlink" title="rm 移除一个或多个容器"></a>rm 移除一个或多个容器</h2><p>docker rm [options] container [container]</p>
<blockquote>
<p>options:<br>-f 强制删除一个运行中的容器<br>-l 移除容器间的网络连接，而非容器本身<br>-v 删除容器关联的卷</p>
</blockquote>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>强制删除nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm -f nginx</span><br></pre></td></tr></table></figure>
<p>移除容器nginx 对容器db1的连接，连接名db:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm -l db</span><br></pre></td></tr></table></figure>
<p>删除容器nginx,并删除容器挂载的数据卷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm -v nginx</span><br></pre></td></tr></table></figure>
<p>删除所有已经停止的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h2 id="pause-unpause-暂停-恢复进程"><a href="#pause-unpause-暂停-恢复进程" class="headerlink" title="pause unpause 暂停/恢复进程"></a>pause unpause 暂停/恢复进程</h2><p>docker pause/unpause container</p>
<h2 id="create-创建容器但不启动它"><a href="#create-创建容器但不启动它" class="headerlink" title="create 创建容器但不启动它"></a>create 创建容器但不启动它</h2><p>docker create [options] image [command] [arg…]</p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>使用镜像nginx:latest创建一个名字为nginx01的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker create --name nginx01 nginx:latest</span><br></pre></td></tr></table></figure>
<h2 id="exec-在运行中的容器执行命令"><a href="#exec-在运行中的容器执行命令" class="headerlink" title="exec 在运行中的容器执行命令"></a>exec 在运行中的容器执行命令</h2><p>docker exec [options] container command [arg…]</p>
<blockquote>
<p>options:<br>-d 在后台运行<br>-i 即使没有附加也保持stdin打开 通常与t一起使用<br>-t 分配一个伪终端 通常与i一起使用</p>
</blockquote>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>在容器nginx中以交互模式执行容器内某脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx &#x2F;bin&#x2F;sh &#x2F;root&#x2F;read.sh</span><br></pre></td></tr></table></figure>
<p>在容器nginx中开启一个交互模式的终端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="ps-列出容器"><a href="#ps-列出容器" class="headerlink" title="ps 列出容器"></a>ps 列出容器</h2><p>docker ps [options]</p>
<blockquote>
<p>options:<br>-a :显示所有的容器，包括未运行的。<br>-f :根据条件过滤显示的内容。<br>–format :指定返回值的模板文件。 –filter “name=test”<br>-l :显示最近创建的容器。<br>-n :列出最近创建的n个容器。<br>–no-trunc :不截断输出。<br>-q :静默模式，只显示容器编号。<br>-s :显示总的文件大小。</p>
</blockquote>
<h2 id="inspect-获取容器-镜像的元数据"><a href="#inspect-获取容器-镜像的元数据" class="headerlink" title="inspect 获取容器/镜像的元数据"></a>inspect 获取容器/镜像的元数据</h2><p>docker inspect [options] name|id </p>
<blockquote>
<p>options:<br>-f 指定返回值的模板文件<br>-s 显示总的文件大小<br>–type 为指定类型返回json</p>
</blockquote>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>获取镜像nginx:latest 的元信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect nginx:latest</span><br><span class="line">返回</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:c7460dfcab502275e9c842588df406444069c00a48d9a995619c243079a4c2f7&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;nginx:latest&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [</span><br><span class="line">            &quot;nginx@sha256:8aa7f6a9585d908a63e5e418dc5d14ae7467d2e36e1ab4f0d8f9d059a3d071ce&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-01-09T22:20:18.366859777Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;613e0b9d718b9d81b04fa7e682d0f770f3a321b34fcc4f790b6304ee1c3ff765&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;613e0b9d718b&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;80&#x2F;tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>获取正在运行的容器nginx的ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; nginx</span><br></pre></td></tr></table></figure>
<h2 id="top-查看容器中运行的进程信息"><a href="#top-查看容器中运行的进程信息" class="headerlink" title="top 查看容器中运行的进程信息"></a>top 查看容器中运行的进程信息</h2><p>docker top contain [ps options]<br>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程,支持ps命令参数</p>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>查看容器nginx的进程信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker top nginx</span><br></pre></td></tr></table></figure>
<h2 id="attach-连接到容器"><a href="#attach-连接到容器" class="headerlink" title="attach 连接到容器"></a>attach 连接到容器</h2><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p>
<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>容器nginx将访问日志指定到标准输出，连接到容器可以查看访问信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach --sig-proxy&#x3D;false nginx</span><br></pre></td></tr></table></figure>
<h2 id="events-从服务器获取实时事件"><a href="#events-从服务器获取实时事件" class="headerlink" title="events 从服务器获取实时事件"></a>events 从服务器获取实时事件</h2><p>docker events [options]</p>
<blockquote>
<p>options:<br>-f 根据条件过滤事件 -f “image=”mysql:5.6”<br>–since 从指定时间戳后显示所有事件 如果是日期可以直接–since=”2020-01-13”，如果是到秒级的，需要将时间转成时间戳<br>–until 流水事件显示到指定时间为止</p>
</blockquote>
<h2 id="logs-查看容器日志"><a href="#logs-查看容器日志" class="headerlink" title="logs 查看容器日志"></a>logs 查看容器日志</h2><p>docker logs [options] container</p>
<blockquote>
<p>options:<br>-f 跟踪日志输出<br>–since :显示某个开始时间的所有日志<br>-t : 显示时间戳<br>–tail :仅列出最新N条容器日志</p>
</blockquote>
<h2 id="wait-阻塞运行直到容器停止，然后打印出它的退出代码"><a href="#wait-阻塞运行直到容器停止，然后打印出它的退出代码" class="headerlink" title="wait 阻塞运行直到容器停止，然后打印出它的退出代码"></a>wait 阻塞运行直到容器停止，然后打印出它的退出代码</h2><h2 id="port-列出容器端口映射"><a href="#port-列出容器端口映射" class="headerlink" title="port 列出容器端口映射"></a>port 列出容器端口映射</h2><p>docker port [options] container [PRIVATE_PORT[/PROTO]]</p>
<h1 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h1><h2 id="images-查看本地镜像列表"><a href="#images-查看本地镜像列表" class="headerlink" title="images 查看本地镜像列表"></a>images 查看本地镜像列表</h2><p>docker images [options] [repository[:tag]]</p>
<blockquote>
<p>options:<br>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br>–digests :显示镜像的摘要信息；<br>-f :显示满足条件的镜像；<br>–format :指定返回值的模板文件；<br>–no-trunc :显示完整的镜像信息；<br>-q :只显示镜像ID</p>
</blockquote>
<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>列出本地镜像中repository为ubuntu的镜像列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images ubuntu</span><br></pre></td></tr></table></figure>
<h2 id="rmi-删除镜像"><a href="#rmi-删除镜像" class="headerlink" title="rmi 删除镜像"></a>rmi 删除镜像</h2><p>docker rmi [options] image [images …]</p>
<blockquote>
<p>options:<br>-f 强制删除<br>–no-prune 不移除该镜像的过程镜像，默认移除</p>
</blockquote>
<h2 id="tag-标记本地镜像，将其归入某一仓库"><a href="#tag-标记本地镜像，将其归入某一仓库" class="headerlink" title="tag 标记本地镜像，将其归入某一仓库"></a>tag 标记本地镜像，将其归入某一仓库</h2><p>docker tag [options] image[:tag] [repository/][username/]name[:tag]</p>
<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>将ubuntu：15.10标记为drookie/ubuntu:v3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag ubuntu:15.10 drookie&#x2F;ubuntu:v3</span><br></pre></td></tr></table></figure>
<h2 id="build-通过dockerfile构建镜像"><a href="#build-通过dockerfile构建镜像" class="headerlink" title="build 通过dockerfile构建镜像"></a>build 通过dockerfile构建镜像</h2><p>docker build [options]  path|url|- </p>
<blockquote>
<p>options:<br>–build-arg=[] :设置镜像创建时的变量；<br>–cpu-shares :设置 cpu 使用权重；<br>–cpu-period :限制 CPU CFS周期；<br>–cpu-quota :限制 CPU CFS配额；<br>–cpuset-cpus :指定使用的CPU id；<br>–cpuset-mems :指定使用的内存 id；<br>–disable-content-trust :忽略校验，默认开启；<br>-f :指定要使用的Dockerfile路径；<br>–force-rm :设置镜像过程中删除中间容器；<br>–isolation :使用容器隔离技术；<br>–label=[] :设置镜像使用的元数据；<br>-m :设置内存最大值；<br>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；<br>–no-cache :创建镜像的过程不使用缓存；<br>–pull :尝试去更新镜像的新版本；<br>–quiet, -q :安静模式，成功后只输出镜像 ID；<br>–rm :设置镜像成功后删除中间容器；<br>–shm-size :设置/dev/shm的大小，默认值是64M；<br>–ulimit :Ulimit配置。<br>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>–network: 默认 default。在构建期间设置RUN指令的网络模式</p>
</blockquote>
<h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t runoob&#x2F;ubuntu:v1 .</span><br></pre></td></tr></table></figure>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build github.com&#x2F;creack&#x2F;docker-firefox</span><br></pre></td></tr></table></figure>
<p>也可以通过 -f Dockerfile 文件的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</span><br></pre></td></tr></table></figure>
<h2 id="history-查看指定镜像的创建历史"><a href="#history-查看指定镜像的创建历史" class="headerlink" title="history 查看指定镜像的创建历史"></a>history 查看指定镜像的创建历史</h2><p>docker history [options] image</p>
<blockquote>
<p>options:<br>-H :以可读的格式打印镜像大小和日期，默认为true；<br>–no-trunc :显示完整的提交记录；<br>-q :仅列出提交记录ID。</p>
</blockquote>
<h2 id="save-将镜像打包成tar文件"><a href="#save-将镜像打包成tar文件" class="headerlink" title="save 将镜像打包成tar文件"></a>save 将镜像打包成tar文件</h2><p>docker save [options] image [image…]</p>
<blockquote>
<p>options:<br>-o 输出到的文件</p>
</blockquote>
<h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><p>将镜像nginx:latest生成nginx_v3.tar文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o nginx_v3.tar nginx:latest</span><br></pre></td></tr></table></figure>
<h2 id="load-导入使用save导出的镜像"><a href="#load-导入使用save导出的镜像" class="headerlink" title="load 导入使用save导出的镜像"></a>load 导入使用save导出的镜像</h2><p>docker load [options]</p>
<blockquote>
<p>options:<br>–input , -i : 指定导入的文件，代替 STDIN。<br>–quiet , -q : 精简输出信息。</p>
</blockquote>
<h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load &lt; nginx_v3.tar</span><br><span class="line">或者</span><br><span class="line">docker load -i nginx_v3.tar</span><br></pre></td></tr></table></figure>
<h1 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h1><h2 id="commit-从容器中创建一个新镜像"><a href="#commit-从容器中创建一个新镜像" class="headerlink" title="commit 从容器中创建一个新镜像"></a>commit 从容器中创建一个新镜像</h2><p>我们在镜像中做的修改可以通过commit命令将其在生成的新镜像中有效<br>docker commit [options] container [repository[:tag]]</p>
<blockquote>
<p>options:<br>-a :提交的镜像作者；<br>-c :使用Dockerfile指令来创建镜像；<br>-m :提交时的说明文字；<br>-p :在commit时，将容器暂停。</p>
</blockquote>
<h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1</span><br></pre></td></tr></table></figure>
<h2 id="cp-容器与主机之间的数据拷贝"><a href="#cp-容器与主机之间的数据拷贝" class="headerlink" title="cp 容器与主机之间的数据拷贝"></a>cp 容器与主机之间的数据拷贝</h2><p>docker cp [options] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [options] SRC_PATH|- CONTAINER:DEST_PATH</p>
<blockquote>
<p>options:<br>-L 保持源目标中的连接</p>
</blockquote>
<h3 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h3><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www</span><br></pre></td></tr></table></figure>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:&#x2F;www &#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="diff-检查容器里文件结构的更改"><a href="#diff-检查容器里文件结构的更改" class="headerlink" title="diff 检查容器里文件结构的更改"></a>diff 检查容器里文件结构的更改</h2><p>docker diff [options] container</p>
<h3 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h3><p>查看容器mymysql的文件结构更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker diff mymysql</span><br><span class="line">A &#x2F;logs</span><br><span class="line">A &#x2F;mysql_data</span><br><span class="line">C &#x2F;run</span><br><span class="line">C &#x2F;run&#x2F;mysqld</span><br><span class="line">A &#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class="line">A &#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">C &#x2F;tmp</span><br></pre></td></tr></table></figure>
<p>以上参考自菜鸟教程</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker系列二docker配置优化</title>
    <url>/docker/2020/docker2/</url>
    <content><![CDATA[<p><a href="/2020/docker1/">docker系列一docker安装</a></p>
<p>工欲善其事必先利其器，所以在安装完docker后，我们需要对docker修改配置。<br>docker的配置文件<strong>是/etc/docker/daemon.json</strong>如果没有这个文件，就新建一个。<br><strong>该配置文件修改完后，需要重启docker使配置生效。</strong><br>重启方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h2><p>使用docker info 可以进行查看docker的信息</p>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>由于默认的docker镜像是从国外拉取的，所以速度会比较慢，所以我们这边采用阿里的镜像仓库，后续我们也可以把自己的镜像推送到阿里云，这样我们在其他服务器拉取镜像就会比较快。</p>
<ol>
<li>阿里云仓库 <a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></li>
<li>进去后有账号的话直接登录，没有的就注册下，登录后在搜索框搜索”容器镜像服务“，选择进入该服务面板。</li>
<li>在镜像中心-镜像加速器，有你的加速地址。下面还有操作文档告诉你怎么操作。/etc/docker/daemon.json中的配置如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;:[&quot;你的阿里云加速地址&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="登录docker"><a href="#登录docker" class="headerlink" title="登录docker"></a>登录docker</h2><p>由于我们将镜像仓库改为阿里云，所以我们需要登录到该仓库。登录账号密码就是网站的登录账号密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker login --username&#x3D;你的账号 \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>
<h2 id="修改docker的存储位置"><a href="#修改docker的存储位置" class="headerlink" title="修改docker的存储位置"></a>修改docker的存储位置</h2><p>我们系统的主要数据是放在另一个额外挂载的大容量硬盘里。最开始的时候，由于docker采用的是默认的存储位置，导致后面镜像太多了，占用了很多存储空间，直接把系统的根目录存储占用满了。所以如果有这个需求的话需要修改下docker的存储位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;graph&quot;:&quot;&#x2F;data&#x2F;docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种修改存储位置的方法，但是我们还是推荐上面那种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants</span><br><span class="line">vim docker.service</span><br><span class="line">#在执行命令中添加--graph&#x3D;你的存储位置</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd --graph&#x3D;&#x2F;data&#x2F;docker .....</span><br></pre></td></tr></table></figure>
<h2 id="日志大小限制"><a href="#日志大小限制" class="headerlink" title="日志大小限制"></a>日志大小限制</h2><p>docker会产生自己的启动日志，所以我们这边为了节省空间，对docker的日志做一些限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;10m&quot;, &quot;max-file&quot;:&quot;2&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附上我的daemon.json所有配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;graph&quot;:&quot;存储位置&quot;,</span><br><span class="line">  &quot;registry-mirrors&quot;:[&quot;你的加速地址&quot;],</span><br><span class="line">  &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;10m&quot;, &quot;max-file&quot;:&quot;2&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker系列一docker安装</title>
    <url>/docker/2020/docker1/</url>
    <content><![CDATA[<p>最近打开印象笔记，发现自己在18年就有做docker的一些相关记录。后面就没了。。没了。。了。。。<br>现在在这家公司，最开始是由于正式使用是内网环境，用docker有点麻烦，就因此把服务docker化部署这个任务闲置了，最近开始公司开始采用联通云，使用云上部署，加上最近自己手头的任务也比较没那么紧张，所以就又开始了docker的研究使用。<br>这里，我将mysql、redis、kafka、nginx进行了根据我们的实际使用进行了定制化。并且将微服务应用进行了使用docker打包，并在正式使用时，使用docker-compose进行编排部署。<br>现在就打算写个blog对自己做的这些做个总结，如果能对大家有帮助的话，更好不过了。  </p>
<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><blockquote>
<p>可能很多朋友都用过虚拟机，我们用的传统虚拟机如 VMware，VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。  </p>
</blockquote>
<h2 id="容器技术与docker"><a href="#容器技术与docker" class="headerlink" title="容器技术与docker"></a>容器技术与docker</h2><blockquote>
<p>容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。<br>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。<br>Linux 容器是 Linux 发展出了另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong> 它是目前最流行的 Linux 容器解决方案。而docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 docker ，就不用担心环境问题。<br>总体来说， Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。  </p>
</blockquote>
<p>在进行了解了下docker后，一切的开始当然是从docker的安装开始，这里我只做docker的ubuntu版本进行操作，其他操作系统看看后面补上。</p>
<h1 id="ubuntu-docker-安装"><a href="#ubuntu-docker-安装" class="headerlink" title="ubuntu docker 安装"></a>ubuntu docker 安装</h1><ol>
<li><p>卸载旧版docker（如果是全新安装的系统，无需执行）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure></li>
<li><p>更新系统软件  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li>
<li><p>安装依赖包  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li>
<li><p>添加官方密钥<br>建议用下面的国内源,下载会更快，执行可能需要小等一会，会出现ok</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg \</span><br><span class="line">| sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p> 以下为官方</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg \</span><br><span class="line">| sudo apt-key add -</span><br></pre></td></tr></table></figure></li>
<li><p>添加仓库<br>建议用下面的国内源  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">&quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">$(lsb_release -cs) \</span><br><span class="line">stable&quot;</span><br></pre></td></tr></table></figure>
<p>以下为官方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">&quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">$(lsb_release -cs) \</span><br><span class="line">stable&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>再次更新软件  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li>
<li><p>安装docker  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure>
<p> 静等下载安装完成。  </p>
</li>
<li><p>查看docker版本  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="red-hat-centos-docker-安装"><a href="#red-hat-centos-docker-安装" class="headerlink" title="red hat/centos docker 安装"></a>red hat/centos docker 安装</h1><ol>
<li>卸载旧版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine-selinux \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure></li>
<li>安装docker源<ol>
<li>安装yum功能包yum-utils用于支持yum-config-manager（yum配置管理器）功能，device-mapper-persistent-data和lv2用户支持devicemapper存储驱动 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data \</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure></li>
<li>增加稳定的docker源 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>安装docker ce<ol>
<li>安装最新的docker ce <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
 如果报 <strong><em>No package docker available</em></strong> yum没有找到docker-ce包，而docker-ce是第三方软件，更新epel后，再次执行上面的安装语句即可 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure>
<h1 id="docker-compose安装-用于多个服务的启动"><a href="#docker-compose安装-用于多个服务的启动" class="headerlink" title="docker-compose安装(用于多个服务的启动)"></a>docker-compose安装(用于多个服务的启动)</h1></li>
</ol>
</li>
<li>安装 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y docker-compose</span><br></pre></td></tr></table></figure></li>
<li>查看版本   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><a href="/2020/docker2/">docker系列二docker配置优化</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>nvidia-docker支持docker使用gpu</title>
    <url>/docker/2020/docker-gpu/</url>
    <content><![CDATA[<h1 id="docker支持使用nvidia驱动"><a href="#docker支持使用nvidia驱动" class="headerlink" title="docker支持使用nvidia驱动"></a>docker支持使用nvidia驱动</h1><p>nvidia-docker是一个可以使用GPU的docker，nvidia-docker是在docker上做了一层封装，通过nvidia-docker-plugin，然后调用到docker上，其最终实现的还是在docker的启动命令上携带一些必要的参数。因此在安装nvidia-docker之前，还是需要安装docker的。<br>docker一般都是使用基于CPU的应用，而如果是GPU的话，就需要安装特有的硬件环境，比如需要安装nvidia driver。所以docker容器并不直接支持Nvidia GPU。为了解决这个问题，最早的处理办法是在容器内部，全部重新安装nvidia driver，然后通过设置相应的设备参数来启动container，然而这种办法是很脆弱的。因为宿主机的driver的版本必须完全匹配容器内的driver版本，这样导致docker image无法共享，很可能本地机器的不一致导致每台机器都需要去重复操作，这很大的违背了docker的设计之初。<br>为了使docker image能很便利的使用Nvidia GPU，从而产生了nvidia-docker，由它来制作nvidia driver的image，这就要求在目标机器上启动container时，确保字符设备以及驱动文件已经被挂载。<br>nvidia-docker-plugin是一个docker plugin，被用来帮助我们轻松部署container到GPU混合的环境下。类似一个守护进程，发现宿主机驱动文件以及GPU 设备，并且将这些挂载到来自docker守护进程的请求中。以此来支持docker GPU的使用</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>需要提前安装好docker，这个可以看之前的文章 docker安装<br>还有一个就是在宿机上安装nvidia显卡驱动，这个自行百度~</p>
<h1 id="nvidia-docker安装"><a href="#nvidia-docker安装" class="headerlink" title="nvidia-docker安装"></a>nvidia-docker安装</h1><p>此处是操作官方文档进行操作 <a href="https://github.com/NVIDIA/nvidia-docker/" target="_blank" rel="noopener">nvidia-docker</a>  </p>
<h2 id="Ubuntu-16-04-18-04-Debian-Jessie-Stretch-Buster"><a href="#Ubuntu-16-04-18-04-Debian-Jessie-Stretch-Buster" class="headerlink" title="Ubuntu 16.04/18.04, Debian Jessie/Stretch/Buster"></a>Ubuntu 16.04/18.04, Debian Jessie/Stretch/Buster</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID)</span><br><span class="line"></span><br><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;gpgkey | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.list | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-docker.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line">    </span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="CentOS-7-docker-ce-RHEL-7-4-7-5-docker-ce-Amazon-Linux-1-2"><a href="#CentOS-7-docker-ce-RHEL-7-4-7-5-docker-ce-Amazon-Linux-1-2" class="headerlink" title="CentOS 7 (docker-ce), RHEL 7.4/7.5 (docker-ce), Amazon Linux 1/2"></a>CentOS 7 (docker-ce), RHEL 7.4/7.5 (docker-ce), Amazon Linux 1/2</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID)</span><br><span class="line"></span><br><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.repo | sudo tee &#x2F;etc&#x2F;yum.repos.d&#x2F;nvidia-docker.repo</span><br><span class="line"></span><br><span class="line">sudo yum install -y nvidia-container-toolkit</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### Test nvidia-smi with the latest official CUDA image</span><br><span class="line">docker run --gpus all nvidia&#x2F;cuda:9.0-base nvidia-smi</span><br><span class="line"></span><br><span class="line"># Start a GPU enabled container on two GPUs</span><br><span class="line">docker run --gpus 2 nvidia&#x2F;cuda:9.0-base nvidia-smi</span><br><span class="line"></span><br><span class="line"># Starting a GPU enabled container on specific GPUs</span><br><span class="line">docker run --gpus &#39;&quot;device&#x3D;1,2&quot;&#39; nvidia&#x2F;cuda:9.0-base nvidia-smi</span><br><span class="line">docker run --gpus &#39;&quot;device&#x3D;UUID-ABCDEF,1&quot;&#39; nvidia&#x2F;cuda:9.0-base nvidia-smi</span><br><span class="line"></span><br><span class="line"># Specifying a capability (graphics, compute, ...) for my container</span><br><span class="line"># Note this is rarely if ever used this way</span><br><span class="line">docker run --gpus all,capabilities&#x3D;utility nvidia&#x2F;cuda:9.0-base nvidia-smi</span><br></pre></td></tr></table></figure>

<h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><p>如果是想自己定义镜像的话 可以直接基于nvidia/cuda的镜像进行操作。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gpu</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
</search>
